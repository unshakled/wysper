// script.js
window.addEventListener('load', () => {
    if (typeof wordlist === "undefined") {
        showModal("Wordlist not loaded. Please ensure eff_wordlist.js is available.");
        return;
    }
    if (wordlist.length !== 7776) {
        showModal("Wordlist should have 7776 words, but found " + wordlist.length);
    }

    // Start in dark mode by default
    document.body.dataset.theme = 'dark';

    // Ensure toggle works
    const toggle = document.getElementById('toggleDark');
    if (!toggle) {
        return;
    }

    // Initialize the theme state based on the dataset and sync with toggle
    const initialTheme = document.body.dataset.theme || 'dark';
    document.body.dataset.theme = initialTheme;
    toggle.checked = initialTheme === 'dark';

    // Toggle dark mode event handler
    toggle.addEventListener('change', () => {
        toggleDarkMode();
    });

    // Handle hash changes for dynamic decrypt page loading
    function checkHash() {
        const hash = window.location.hash.slice(1);
        if (hash) {
            document.getElementById("create").style.display = "none";
            document.getElementById("decrypt").style.display = "block";
        } else {
            document.getElementById("create").style.display = "block";
            document.getElementById("decrypt").style.display = "none";
        }
    }

    // Initial check and listen for hash changes
    checkHash();
    window.addEventListener('hashchange', checkHash);

    // Character countdown for message
    const messageInput = document.getElementById('message');
    const charCounter = document.getElementById('charCounter');
    const maxLength = 1500;
    function updateCharCounter() {
        const remaining = maxLength - messageInput.value.length;
        charCounter.textContent = `Characters remaining: ${remaining}`;
        charCounter.style.color = remaining < 100 ? "var(--error)" : "var(--light-text)";
    }
    messageInput.addEventListener('input', updateCharCounter);
    updateCharCounter(); // Initial call

    // Smooth scroll to sections
    document.querySelectorAll('nav a').forEach(anchor => {
        anchor.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const target = document.getElementById(targetId);
            if (target) {
                target.scrollIntoView({ behavior: 'smooth' });
                target.style.animation = 'smoothScroll 0.8s ease-in-out';
                setTimeout(() => {
                    target.style.animation = '';
                }, 800);
            }
        });
    });
});

// Function to go home and clear hash
function goHome(event) {
    event.preventDefault();
    history.pushState("", document.title, window.location.pathname + window.location.search);
    document.getElementById("create").style.display = "block";
    document.getElementById("decrypt").style.display = "none";
}

function showModal(message) {
    const modal = document.getElementById('modal');
    const modalMessage = document.getElementById('modal-message');
    modalMessage.textContent = message;
    modal.style.display = 'flex';
    setTimeout(() => {
        closeModal();
    }, 5000);
}

function closeModal() {
    const modal = document.getElementById('modal');
    modal.style.display = 'none';
}

// Toggle dark/light themes
function toggleDarkMode() {
    const currentTheme = document.body.dataset.theme;
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    if (currentTheme !== newTheme) {
        document.body.dataset.theme = newTheme;
        const toggle = document.getElementById('toggleDark');
        toggle.checked = newTheme === 'dark';
    }
}

// Estimate passphrase entropy
function estimateEntropy(passphrase) {
    const words = passphrase.trim().split(/\s+/).filter(word => word.length > 0);
    if (words.length < 7) return words.length * 4;
    const uniqueWords = new Set(words).size;
    const wordlistSize = 7776;
    const maxEntropyPerWord = Math.log2(wordlistSize);
    const effectiveEntropy = Math.floor(maxEntropyPerWord * uniqueWords);
    return effectiveEntropy >= 80 ? effectiveEntropy : 0;
}

// Update entropy meter whenever passphrase changes
document.getElementById("passphrase").addEventListener("input", () => {
    const entropy = estimateEntropy(document.getElementById("passphrase").value);
    const meter = document.getElementById("entropyMeter");
    meter.innerText = `Entropy: ${entropy} bits`;
    meter.style.color = entropy < 80 ? "var(--error)" : "var(--success)";
});

function generatePassphrase() {
    if (!wordlist || wordlist.length < 7) {
        showModal("Wordlist unavailable or too small.");
        return;
    }

    const wordCount = 7;
    const indices = new Set();
    const maxIndex = wordlist.length;
    const randomValues = crypto.getRandomValues(new Uint32Array(wordCount));

    for (let i = 0; i < wordCount; i++) {
        const index = Math.floor(randomValues[i] / (0xffffffff + 1) * maxIndex);
        indices.add(index);
        while (indices.size < i + 1) {
            const newIndex = Math.floor(crypto.getRandomValues(new Uint32Array(1))[0] / (0xffffffff + 1) * maxIndex);
            indices.add(newIndex);
        }
    }

    const passphrase = Array.from(indices)
        .map(index => wordlist[index])
        .join(" ");
    document.getElementById("passphrase").value = passphrase;
}

function copyPassphrase() {
    const passphrase = document.getElementById("passphrase").value;
    if (passphrase) {
        navigator.clipboard.writeText(passphrase);
        showModal("Copied passphrase to clipboard!");
    }
}

function copyLink() {
    const linkElement = document.querySelector('#link span');
    if (linkElement) {
        const url = linkElement.textContent.trim();
        navigator.clipboard.writeText(url);
        showModal("Copied link to clipboard!");
    }
}

async function encryptMessage() {
    const message = document.getElementById("message").value;
    const passphrase = document.getElementById("passphrase").value;
    const selfDestruct = parseInt(document.getElementById("selfDestruct").value);

    if (!message || !passphrase) {
        showModal("Please enter both a message and a passphrase.");
        return;
    }

    const entropy = estimateEntropy(passphrase);
    if (entropy < 80) {
        showModal(`Passphrase too weak (${entropy} bits). Use 7+ unique random words.`);
        return;
    }

    try {
        const encoder = new TextEncoder();
        const messageBytes = encoder.encode(message);
        const salt = crypto.getRandomValues(new Uint8Array(16));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const expiry = Math.floor(Date.now() / 1000) + (7 * 86400);
        const expiryBytes = new Uint8Array(4);
        new DataView(expiryBytes.buffer).setUint32(0, expiry);
        const sdBytes = new Uint8Array(1);
        sdBytes[0] = selfDestruct;

        const keyMaterial = await crypto.subtle.importKey(
            "raw",
            encoder.encode(passphrase),
            { name: "PBKDF2" },
            false,
            ["deriveKey"]
        );
        const key = await crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: 1000000, hash: "SHA-256" },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt"]
        );

        const encrypted = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            key,
            messageBytes
        );

        const combined = new Uint8Array(
            salt.length + iv.length + expiryBytes.length + sdBytes.length + encrypted.byteLength
        );
        combined.set(salt, 0);
        combined.set(iv, salt.length);
        combined.set(expiryBytes, salt.length + iv.length);
        combined.set(sdBytes, salt.length + iv.length + expiryBytes.length);
        combined.set(new Uint8Array(encrypted), salt.length + iv.length + expiryBytes.length + sdBytes.length);

        const base64 = btoa(String.fromCharCode.apply(null, Array.from(combined)));
        if (base64.length > 1500) {
            showModal("Message too long for reliable URL storage. Shorten it for best results.");
            return;
        }

        const url = `${window.location.origin}/#${encodeURIComponent(base64)}`;
        document.getElementById("link").innerHTML = `Click to share this Wysper: <span onclick="copyLink()">${url}</span>`;
    } catch (e) {
        showModal("Error encrypting message.");
    }
}

async function decryptMessage() {
    const passphrase = document.getElementById("decryptPassphrase").value;
    if (!passphrase) {
        showModal("Please enter a passphrase.");
        return;
    }

    try {
        const combined = Uint8Array.from(atob(decodeURIComponent(window.location.hash.slice(1))), c => c.charCodeAt(0));
        const salt = combined.slice(0, 16);
        const iv = combined.slice(16, 28);
        const expiry = new DataView(combined.slice(28, 32).buffer).getUint32(0);
        const selfDestruct = combined[32];
        const ciphertext = combined.slice(33);

        if (Math.floor(Date.now() / 1000) > expiry) {
            showModal("Message has expired.");
            return;
        }

        const encoder = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey(
            "raw",
            encoder.encode(passphrase),
            { name: "PBKDF2" },
            false,
            ["deriveKey"]
        );
        const key = await crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: 1000000, hash: "SHA-256" },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            false,
            ["decrypt"]
        );

        const decrypted = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv },
            key,
            ciphertext
        );
        const decoder = new TextDecoder();
        const message = decoder.decode(decrypted);
        document.getElementById("output").innerText = "Decrypted Message: " + message;

        // Clear passphrase field after decrypt
        document.getElementById("decryptPassphrase").value = "";

        // Handle existing timer and start new one if self-destruct is set
        const timer = document.getElementById("selfDestructTimer");
        const timerSeconds = document.getElementById("timerSeconds");
        // Clear any existing timer
        if (timer.dataset.countdown) {
            clearInterval(timer.dataset.countdown);
            delete timer.dataset.countdown;
        }
        if (timer.style.display === "block") {
            document.getElementById("output").innerText = "Decrypted Message: " + message; // Reset to current message
            timer.style.display = "none";
        }
        if (selfDestruct > 0) {
            let timeLeft = selfDestruct;
            timer.style.display = "block";
            const countdown = setInterval(() => {
                timerSeconds.textContent = timeLeft;
                if (timeLeft <= 0) {
                    clearInterval(countdown);
                    document.getElementById("output").innerText = "Message self-destructed.";
                    timer.style.display = "none";
                    delete timer.dataset.countdown;
                }
                timeLeft--;
            }, 1000);
            timer.dataset.countdown = countdown; // Store the new interval ID
        }
    } catch (e) {
        showModal("Decryption failed. Wrong passphrase or invalid link.");
    }
}
